# Backend Agent Guidelines

## Commands
- **Dev**: `yarn dev`, `yarn dev:inspect`
- **Build**: `yarn build`
- **DB**: `yarn db g <name>`, `yarn db up`, `yarn db seed`, `yarn test:db:setup`
- **Tests**: `yarn test`, `yarn test:ui`, `yarn test:coverage`

## Stack
oRPC (type-safe APIs), Orchid ORM (PostgreSQL), pg-tbus (task queue), Better Auth (Google OAuth), Vitest (tests), OpenTelemetry, Sentry, SuprSend (notifications)

## Structure
```
src/
├── modules/          # Features: auth, journal-entries, prompts, logs, subscriptions, teams, users, webhook_calls
├── routers/          # user_app/ - oRPC routes, open_api/ - external APIs, cron_jobs/ - cron jobs
├── procedures/       # public, protected, sensitive, open_api_public, cron_job_auth
├── middlewares/      # API key auth, IP whitelist, session security, cron job auth
├── events/           # pg-tbus events & tasks
├── cron_jobs/        # Cron job handlers
├── db/              # Tables, migrations, seeds
└── server.ts        # Entry
```

## Database Tables

**Create Table** (`modules/<module>/tables/<entity>.table.ts`):
```typescript
import { BaseTable } from '../../../db/base_table';

export class EntityNameTable extends BaseTable {
  readonly table = 'entity_name';
  columns = this.setColumns((t) => ({
    entityId: t.uuid().primaryKey().default(t.sql`gen_random_uuid()`),
    authorUserId: t.uuid().foreignKey('users', 'userId'),
    content: t.text(),
    ...this.baseTableColumns(t),  // createdAt, updatedAt
  }));
}
```

**Rules**:
- Descriptive IDs: `userId`, `entityId` (not `id`)
- Descriptive FKs: `authorUserId` (not `authorId`)
- Use `timestampNumber` for timestamps (epoch ms)
- snake_case columns, PascalCase class

**Zod Schemas** (`packages/zod-schemas/src/<entity>.zod.ts`):
```typescript
import z from 'zod';
import { zString, zTimestamps } from './zod_utils.js';

export const entityMandatoryZod = z.object({
  content: zString.min(1),
});

export const entityOptionalZod = z.object({
  description: zString.nullable(),
});

const entityAutoGeneratedZod = z.object({
  entityId: z.string().uuid(),
  authorUserId: z.string().uuid(),
});

export const entityCreateInputZod = entityMandatoryZod.extend(
  entityOptionalZod.partial().shape
);

export const entityUpdateInputZod = entityMandatoryZod
  .extend(entityOptionalZod.shape)
  .extend(zTimestamps)
  .partial();

export const entitySelectAllZod = entityMandatoryZod
  .extend(entityOptionalZod.shape)
  .extend(zTimestamps)
  .extend(entityAutoGeneratedZod.shape);
```

**Register** in `db/db.ts`, generate migration: `yarn db g <name>`, run: `yarn db up`

## Migrations (CRITICAL)

**Rule #1**: Migrations MUST be auto-generated via:
```bash
yarn db g <migration_name>   # ALWAYS use this command
yarn db up                   # Apply migrations
```

**Rule #2**: Never write migrations manually unless the auto-generator fails with an error.

**Rule #3**: Migrations MUST be backward compatible:
- Migration runs successfully even if frontend/backend are older versions
- Never remove columns immediately - mark deprecated first, remove in later migration
- Add new columns as nullable or with defaults
- Rename columns: add new, migrate data, drop old (across multiple migrations)

> ⚠️ **WARNING**: Our containers use start-first logic. If you write a migration that is NOT backward compatible (e.g., deleting a column that the old code still needs), the deployment will fail because the old container will still be running and trying to access that deleted column while the new one starts.

**Rule #4**: Test migrations on production-like data before deploying.

## oRPC Endpoints

**Create Procedure** (`modules/<module>/<module>.router.ts`):
```typescript
import { rpcProtectedProcedure } from '../../procedures/protected.procedure';
import { entityCreateInputZod } from '@connected-repo/zod-schemas/entity.zod';
import { db } from '../../db/db';

export const createEntity = rpcProtectedProcedure
  .input(entityCreateInputZod)
  .handler(async ({ input, context }) => {
    return db.entities.create({
      ...input,
      authorUserId: context.user.id,
    });
  });
```

**Procedures**:
- `rpcPublicProcedure`: No auth
- `rpcProtectedProcedure`: Requires session & user
- `rpcSensitiveProcedure`: Extra security

**Register** in `routers/user_app/user_app.router.ts`

## Events & Tasks (pg-tbus)

**Event-Driven Architecture** using pg-tbus (PostgreSQL-based task bus):

**Define Event** (`events/events.schema.ts`):
```typescript
import { defineEvent, Type } from 'pg-tbus';

export const entityCreatedEventDef = defineEvent({
  event_name: "entity.created",
  schema: Type.Object({
    entityId: Type.String({ format: "uuid" }),
    userId: Type.String(),
  }),
});
```

**Define Task** (`events/events.schema.ts`):
```typescript
import { defineTask, Type } from 'pg-tbus';

export const notificationTaskDef = defineTask({
  task_name: "send_notification",
  schema: Type.Object({
    userId: Type.String(),
    message: Type.String(),
  }),
  config: {
    retryLimit: 3,
    retryDelay: 10,
    retryBackoff: true,    // Exponential: 10s, 20s, 40s
    expireInSeconds: 300,  // 5 min timeout per attempt
    keepInSeconds: 604800, // 7 days retention
  },
});
```

**Register Handlers** (`events/events.queries.ts`):
```typescript
import { tbus } from './tbus';
import { entityCreatedEventDef } from './events.schema';

export function registerEventHandlers() {
  tbus.on(entityCreatedEventDef, async ({ payload }) => {
    await handleEntityCreated(payload);
  });
}
```

**Emit Event**:
```typescript
import { tbus } from '../../events/tbus';
import { entityCreatedEventDef } from '../../events/events.schema';

await tbus.emit(entityCreatedEventDef, { entityId: "123", userId: "456" });
```

**Setup** (`events/tbus.ts`):
```typescript
import createTBus from 'pg-tbus';

export const tbus = createTBus(env.OTEL_SERVICE_NAME, {
  db: { host, port, user, password, database },
  schema: "tbus"
});
```

## Cron Jobs

**Per-minute cron jobs** using node-cron:

```typescript
// src/cron_jobs/services/per_minute_cron.ts
import * as cron from 'node-cron';

let isCronJobRunning = false;

export const perMinuteCronJobs: cron.ScheduledTask = cron.schedule(
  '* * * * *',
  async () => {
    if (isCronJobRunning) {
      logger.warn('Skipping cron job - previous job still running');
      return;
    }

    isCronJobRunning = true;
    try {
      await runScheduledTasks();
    } finally {
      isCronJobRunning = false;
    }
  }
);
```

**Mutex pattern prevents concurrent execution.**

## Testing

**Setup**: `yarn test:db:setup` (drop, create, migrate, seed test DB)

**Test** (`modules/<module>/<module>.test.ts`):
```typescript
import { beforeAll, describe, expect, test } from 'vitest';
import { db } from '../../db/db';
import { createTestUserAndSession } from '../../test/utils/user-auth.utils';

describe('ModuleName', () => {
  let userId: string;

  beforeAll(async () => {
    const result = await createTestUserAndSession(db);
    userId = result.userId;
  });

  test('create', async () => {
    const entity = await db.entities.create({
      content: 'Test',
      authorUserId: userId,
    });
    expect(entity.entityId).toBeDefined();
  });
});
```

## Auth

**Better Auth**: Google OAuth in `modules/auth/auth.config.ts`, custom Orchid adapter
**Auth Middleware**: Validates session & user in `modules/auth/auth.middleware.ts`
**API Key Auth**: Scrypt-hashed team API keys in `middlewares/api-key-auth.middleware.ts`
**Cron Job Auth**: Bearer token auth in `middlewares/cron-job-auth.middleware.ts`

## Error Handling

**Error Parser** (`utils/errorParser.ts`): Converts DB/validation errors to user-friendly messages
**Usage**: `throw new Error(handleErrors(error))`
**oRPC**: Auto-catches and formats errors

## Notifications (SuprSend)

**Configuration**: `configs/suprsend.config.ts`

**Send Notification**:
```typescript
import { suprClient } from '../../configs/suprsend.config';
import { Event } from '@suprsend/node-sdk';

const event = new Event(userId, 'EVENT_NAME', { property: 'value' });
const result = await suprClient.track_event(event);
if (!result.success) throw new Error(`SuprSend failed: ${result.message}`);
```

## Webhook Processing

**Task Handler** (`modules/webhook_calls/handlers/<webhook>.handler.ts`):
```typescript
import { subscriptionAlertWebhookTaskDef } from '../../events/events.schema';

export const subscriptionAlertWebhookHandler = async ({ input }) => {
  const { subscriptionId, teamId, payload } = input;
  
  // Log start to pg_tbus_task_log
  await db.pgTbusTaskLogs.create({ taskName, status: 'active', ... });
  
  try {
    const response = await axios.post(webhookUrl, payload, { headers });
    
    // Update log with success
    await db.pgTbusTaskLogs.find(logId).update({
      status: 'completed', success: true, responseStatusCode: response.status,
    });
    
    return { success: true };
  } catch (error) {
    // Update log with failure
    await db.pgTbusTaskLogs.find(logId).update({
      status: 'failed', success: false, errorMessage: error.message, willRetry: true,
    });
    throw error; // pg-tbus will retry
  }
};
```

**Audit Logging**: All webhook attempts logged to `pg_tbus_task_log` table for observability.

## OpenAPI Endpoints

**Procedure** (`procedures/open_api_public.procedure.ts`): Base procedure with error definitions
**Router** (`routers/open_api/open_api.router.ts`): External REST APIs with Swagger docs at `/api/documentation`
**Request Logging**: All API calls logged to `api_product_request_logs` table
**Subscription Usage**: Atomic increment with 90% threshold alerts via webhooks

**Create Endpoint** (`modules/<module>/<module>.openapi.router.ts`):
```typescript
const createRequest = openApiPublicProcedure
  .route({ method: "POST", tags: ["<Module>"] })
  .input(openapiCreateInputZod)
  .output(apiProductRequestLogSelectAllZod)
  .handler(async ({ context: { team }, input }) => {
    const logEntry = await createRequestLog(input, reqHeaders, path, team.teamId);
    const { subscription } = await checkSubscriptionAndUpdateLog(logEntry, "product", sku, teamId, userRef);
    if (!subscription) return logEntry;

    await incrementSubscriptionUsage(subscription.subscriptionId, team);
    // Process request
    return logEntry;
  });
```

## Environment

**Config**: `configs/env.config.ts` (Zod validation)
**Key Vars**: `NODE_ENV`, `DATABASE_URL`, `GOOGLE_CLIENT_ID/SECRET`, `BETTER_AUTH_SECRET`, `SUPRSEND_API_KEY`, `CRON_JOB_TOKEN`, `OTEL_SERVICE_NAME`

## Common Patterns

**Create with Author**:
```typescript
export const createEntity = rpcProtectedProcedure
  .input(entityCreateInputZod)
  .handler(async ({ input, context }) => {
    return db.entities.create({ ...input, authorUserId: context.user.id });
  });
```

**Query with User Filter**:
```typescript
export const getUserEntities = rpcProtectedProcedure
  .handler(async ({ context }) => {
    return db.entities.where({ authorUserId: context.user.id });
  });
```

**Update with Ownership**:
```typescript
export const updateEntity = rpcProtectedProcedure
  .input(entityUpdateInputZod)
  .handler(async ({ input, context }) => {
    const entity = await db.entities.findBy({ entityId: input.id });
    if (entity.authorUserId !== context.user.id) throw new Error('Unauthorized');
    return db.entities.find(input.id).update(input);
  });
```

**Transaction**:
```typescript
await db.$transaction(async (tx) => {
  await tx.entities.create(entityData);
  await tx.logs.create(logData);
});
```

**Emit Event**:
```typescript
await tbus.emit(eventDef, payload);
```

**Send Webhook** (via task):
```typescript
await tbus.task(webhookTaskDef).send({ subscriptionId, teamId, payload });
```

## Real-Time Sync & Soft Deletes

### Sync Service (SSE)
The backend uses a singleton `syncService` to broadcast data changes to connected clients.

```typescript
// modules/journal-entries/journal-entries.router.ts
import { syncService } from '../sync/sync.service';

await db.journalEntries.create(input);
syncService.push({
  type: 'journalEntries',
  operation: 'create',
  data: result
});
```

### Soft Delete Support
All primary entities should support soft deletes to ensure the local client store can stay in sync without losing references.

- Use the `deletedAt` column.
- The `SyncManager` on the client looks for `deletedAt` tombstones to remove local records.

### Delta Sync
Endpoints should support a `since` parameter (timestamp) to allow clients to fetch only what has changed since their last sync.

```typescript
// modules/sync/sync.router.ts
export const getDelta = rpcProtectedProcedure
  .input(z.object({ since: z.union([z.string(), z.number()]).optional() }))
  .handler(async ({ input }) => {
     // Fetch records updated after 'since'
  });
```

---

## Best Practices
- NO `any` or `as unknown`
- Infer types from Zod
- Direct imports, NO barrel exports
- Test all CRUD ops
- Use transactions for multi-table ops
- Index frequently queried columns
- Hash sensitive data (scrypt for API keys)
- Log with appropriate level
- Always auto-generate migrations, never manual
- Make migrations backward compatible
- Use pg-tbus for async tasks, notifications, webhooks
- Always log pg-tbus task execution to `pg_tbus_task_log`
- **Sync**: Push all data-modifying changes to `syncService`.
