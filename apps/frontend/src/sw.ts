import { cleanupOutdatedCaches, createHandlerBoundToURL, precacheAndRoute } from 'workbox-precaching';
import { NavigationRoute, registerRoute } from 'workbox-routing';
import { createORPCClient, onError } from '@orpc/client';
import { RPCLink } from '@orpc/client/fetch';
import { SimpleCsrfProtectionLinkPlugin } from '@orpc/client/plugins';
import type { UserAppRouter } from "../../backend/src/routers/user_app/user_app.router";

declare const self: ServiceWorkerGlobalScope;

// Inject the precache manifest (generated by the plugin)
precacheAndRoute(self.__WB_MANIFEST);

// Clean up old caches from previous versions
cleanupOutdatedCaches();

self.addEventListener('install', () => {
  self.skipWaiting();
});

let isSyncing = false;
let lastKnownStatus: 'connected' | 'disconnected' | 'connecting' = 'disconnected';
let abortController: AbortController | null = null;

// Listen for messages
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    console.log('[SW] SKIP_WAITING received');
    (self as ServiceWorkerGlobalScope).skipWaiting();
  }

  if (event.data && event.data.type === 'INIT_SYNC') {
    const { apiUrl, forceRestart } = event.data.payload;
    console.log(`[SW] Received INIT_SYNC. apiUrl: ${apiUrl}, forceRestart: ${forceRestart}, isSyncing: ${isSyncing}`);
    
    // Always broadcast current status to the client
    broadcastToClients({ type: 'SSE_STATUS_UPDATE', payload: { status: lastKnownStatus } });

    if (isSyncing && !forceRestart) {
      console.log(`[SW] Already syncing and no forceRestart, ignoring.`);
      return;
    }

    if (forceRestart && abortController) {
      console.log(`[SW] Force restart requested, aborting current stream to trigger reconnection.`);
      abortController.abort();
      // The while(true) loop in startSyncing will catch this and continue immediately.
      return;
    }

    startSyncing(apiUrl).catch(err => {
      console.error(`[SW] startSyncing caught error:`, err);
      isSyncing = false;
    });
  }
});

function updateStatus(status: typeof lastKnownStatus) {
  console.log(`[SW] Status update: ${lastKnownStatus} -> ${status}`);
  lastKnownStatus = status;
  broadcastToClients({ type: 'SSE_STATUS_UPDATE', payload: { status } });
}

async function startSyncing(apiUrl: string) {
  if (isSyncing) {
    console.log('[SW] startSyncing called but already syncing. Exiting.');
    return;
  }
  
  console.log(`[SW] Entering sync loop for ${apiUrl}`);
  isSyncing = true;

  try {
    const link = new RPCLink({
      url: `${apiUrl}/user-app`,
      fetch: (request, init) => globalThis.fetch(request, { ...init, credentials: 'include' }),
      plugins: [new SimpleCsrfProtectionLinkPlugin()],
    });

    const orpc = createORPCClient<UserAppRouter>(link);

    while (true) {
      let watchdogTimer: any = null;
      const WATCHDOG_TIMEOUT = 30000;

      const resetWatchdog = () => {
        if (watchdogTimer) clearTimeout(watchdogTimer);
        watchdogTimer = setTimeout(() => {
          console.error('[SW] Sync watchdog expired! No heartbeat/data received for 30s. Aborting stream to trigger reconnect.');
          if (abortController) {
             abortController.abort();
          }
        }, WATCHDOG_TIMEOUT);
      };

      try {
        updateStatus('connecting');
        
        abortController = new AbortController();
        console.log(`[SW] Calling liveSync at ${apiUrl}/user-app...`);
        const stream = await (orpc.sync as any).liveSync({}, { signal: abortController.signal });

        console.log(`[SW] Live sync stream connected!`);
        updateStatus('connected');
        resetWatchdog();

        for await (const event of stream) {
          console.log(`[SW] Received sync event from server (type: ${event.type})`);
          resetWatchdog();
          
          if (event.type !== 'heartbeat') {
            broadcastToClients({ type: 'SYNC_UPDATE', payload: event });
          }
        }
        
        console.warn(`[SW] Live sync stream ended normally? Reconnecting...`);
        updateStatus('disconnected');
      } catch (err: any) {
        updateStatus('disconnected');
        
        if (err && err.name === 'AbortError') {
          console.log(`[SW] Stream aborted/watchdog expired. Reconnection loop will continue.`);
          continue; 
        }

        const errorMsg = err instanceof Error ? err.message : String(err);
        const errorStack = err instanceof Error ? err.stack : '';
        const isAuthError = errorMsg.toLowerCase().includes('authenticated') || err.status === 401;
        
        const backoff = isAuthError ? 30000 : 5000;
        console.error(`[SW] Sync stream error (Auth=${isAuthError}, Status=${err.status}). Reconnecting in ${backoff/1000}s...`, {
          message: errorMsg,
          err,
          stack: errorStack
        });
        
        await new Promise(r => setTimeout(r, backoff));
      } finally {
        if (watchdogTimer) clearTimeout(watchdogTimer);
        if (abortController) {
          abortController.abort();
          abortController = null;
        }
      }
    }
  } finally {
    console.warn(`[SW] Sync loop terminated for ${apiUrl}. Resetting isSyncing state.`);
    isSyncing = false;
  }
}

self.addEventListener('activate', (event) => {
  event.waitUntil((self as any).clients.claim());
});

async function broadcastToClients(message: any) {
  const clients = await (self as any).clients.matchAll({ includeUncontrolled: true, type: 'window' });
  console.log(`[SW] Broadcasting to ${clients.length} clients:`, message.type);
  for (const client of clients) {
    client.postMessage(message);
  }
}

try {
  registerRoute(
    new NavigationRoute(createHandlerBoundToURL('./index.html'))
  );
} catch (err) {
  console.warn('[SW] NavigationRoute registration failed (likely index.html not precached in dev):', err);
}